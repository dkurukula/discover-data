
<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="https://unpkg.com/dc@4/dist/style/dc.css" />
    <script src="https://unpkg.com/d3@5/dist/d3.js"></script>
    <script src="https://unpkg.com/crossfilter2@1.5/crossfilter.js"></script>
    <script src="https://unpkg.com/dc@4/dist/dc.js"></script>
    <script src="https://rawgit.com/crossfilter/reductio/master/reductio.js"></script>
    <script src="https://npmcdn.com/universe@latest/universe.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous">
    <style>
     input[type=checkbox] {
         position: relative;
         width: 1.25em;
         height: 1.25em;
         color: #363839;
         border: 1px solid #bdc1c6;
         padding: .25em;
         margin: 0.25em;
         margin-left: 0.75em;
     }
     label {
         position: relative;
         cursor: pointer;
         font-size: 1.25em;
         top: 50%;
         font-weight: 200;
         padding-bottom:.5em;
     }

    </style>
</head>

<body>
    <div class="container">
        <h2>Toronto Open Data</h2>
        <div id="freq"></div>
        <br>
        <a href="#">reset</a>
        <h4>Topics to include</h4>
        <div class="container" id="topic"></div>
        <h4>Topics to exclude</h4>
        <div class="container" id="extopic"></div>
        <br>
        <div style="clear: both"></div>
        <div id="datatable" class="table"></div>
    </div>
    <script>

     const TOPICS = 'topics'
     const EXTOPICS = 'extopics'
     const TOPICS_CB = 'topics_chekcboxes'
     const EXTOPICS_CB = 'extopics_chekcboxes'

     JSON.flatten = function(data) {
         var result = {};
         function recurse (cur, prop) {
             if (Object(cur) !== cur) {
                 result[prop] = cur;
             } else if (Array.isArray(cur)) {
                 for(var i=0, l=cur.length; i<l; i++)
                     recurse(cur[i], prop ? prop+"."+i : ""+i);
                 if (l == 0)
                     result[prop] = [];
             } else {
                 var isEmpty = true;
                 for (var p in cur) {
                     isEmpty = false;
                     recurse(cur[p], prop ? prop+"."+p : p);
                 }
                 if (isEmpty)
                     result[prop] = {};
             }
         }
         recurse(data, "");
         return result;
     }


     const getAllCommaList = (data, key) => {
         let all = data.map( d => {
             let dk = d[`${key}`]
             if (dk == null){ return "" } else { return dk.split(",") }
         })
         let unique = [...new Set(all.flat())].filter( x => x !== "")
         return unique
     }

     var chart = dc.barChart("#freq"),
         datatable = new dc.DataTable('#datatable');

     d3.json("tor-dat.json").then((data) => {
         data.forEach(x => {
             x.num_tags = +x.num_tags;
             x.refresh_rate = `${x.refresh_rate}`;
             x.formats = `${x.formats}`;
         });
         var ndx = crossfilter(data),
             numTagsDim = ndx.dimension(d => +d.num_tags),
             numTagsSumGroup = numTagsDim.group().reduceSum(d => +d.num_tags ),
             topicsDim = ndx.dimension( d => d.topics );


         dimRefreshRate = ndx.dimension(d => d.refresh_rate);
         dimFormats= ndx.dimension(d => d.formats);

         chart
             .width(768)
             .height(480)
             .x(d3.scaleBand())
             .xUnits(dc.units.ordinal)
             .brushOn(false)
             .dimension(dimRefreshRate)
             .barPadding(0.1)
             .outerPadding(.05)
             .group(dimRefreshRate.group())
             .xAxisLabel("Data update frequency")
         chart.render();

         datatable
             .dimension(dimRefreshRate)
             .section(d => `${d.refresh_rate}`)
             .columns(['title', 'topics'])
             .size(data.length);

         dc.renderAll();

         let allTopics = getAllCommaList(data,'topics')

         createTopicCheckBoxes = (name) => {
             allTopics.forEach( topic => {
                 let label = document.createElement('label')
                 let description = document.createTextNode(topic)
                 checkbox = document.createElement('input')
                 checkbox.type = 'checkbox'
                 checkbox.name = name 
                 checkbox.id = `${name}_${topic}`
                 checkbox.value = `${topic}`
                 checkbox.class = 'btn-check'
                 label.appendChild(checkbox)
                 label.appendChild(description)
                 document.querySelector(`#${name}`).appendChild(label)
             })
         }

         createTopicCheckBoxes('topic')
         createTopicCheckBoxes('extopic')

         const state = {}
         state[TOPICS] = []
         state[EXTOPICS] = []
         state[TOPICS_CB] = document.querySelectorAll("input[type=checkbox][name=topic]");
         state[EXTOPICS_CB]= document.querySelectorAll("input[type=checkbox][name=extopic]");
         
         const includesTopic = (d, topics) => {
             return topics.some(x => d.split(',').includes(x))
         } 

         const excludesTopic = (d, topics) => {
             return d.split(',').filter(x => topics.includes(x)).length===0
         }

         const filterTopic = (state) => {
             topicsDim.filterFunction(d => {
                 if (d){
                     return (includesTopic(d, state[TOPICS]) && excludesTopic(d, state[EXTOPICS]))
                 } else {
                     return false 
                 }
             })
             dc.redrawAll();
         }
         

         console.log("before event listener")

         const updateTopicArr = (checked, val, state, key) => {
             if(checked) {
                 state[key] ? state[key]= [...state[key]].concat(val): state[key]= [val]
             } else {
                 state[key]= [...state[key]].filter( i => i !== val)
             }
             return state[key]
         }

         const toggCheckBoxes= (state, key, keyCbToDisable) =>{
             state[keyCbToDisable].forEach( el => el.disabled = false)
             if (state[key].length>0){
                 state[key].forEach( topic => {
                     state[keyCbToDisable].forEach( cb => {
                         if (cb.value === topic)
                             cb.disabled = true
                     })
                 })
             }
         }

         function addCbEventListener(){
             state[TOPICS_CB].forEach( cb => {
                 cb.addEventListener( 'change', function() {
                     state[TOPICS] = updateTopicArr(this.checked, this.value, state, TOPICS)
                     toggCheckBoxes(state, TOPICS, EXTOPICS_CB)
                     filterTopic(state)
                 });
             })
         }

         function addexCbEventListener(){
             state[EXTOPICS_CB].forEach( cb => {
                 cb.addEventListener( 'change', function() {
                     state[EXTOPICS] = updateTopicArr(this.checked, this.value, state, EXTOPICS)
                     toggCheckBoxes(state, EXTOPICS, TOPICS_CB)
                     filterTopic(state)
                 });
             })
         }

         addCbEventListener()
         addexCbEventListener()

         console.log("after event listener")

     });
    </script>
</body>
